/******************************************************************
 * Programa que genera una onda senoidal usando una red neuronal
 * MLP superficial
 * Autor:
 *      Jesús Alfonso López 
 *      jalopez@uao.edu.co
 ******************************************************************/

#include <math.h>

/******************************************************************
 * Definición estructura de la red
 ******************************************************************/

const int HiddenNodes = 10;
const int InputNodes = 4;
const int OutputNodes = 1;
const int DataVal = 50;
int Samples=0;

// Los pesos de la red fueron obtenidos en TensorFlow y se copiaron a este programa
// Pesos capa oculta
const float HiddenWeights[HiddenNodes][InputNodes+1]= {
{-0.9525454044342041, -0.0009335255017504096,  -3.372152805328369,  0.03238999471068382, 12.462760925292969},
{-0.4058261811733246, 0.3421765863895416,  -2.075134515762329,  -0.5508534908294678, -0.0094069205224514},
{1.5959241390228271,  -0.05908389762043953,  1.0366990566253662,  -0.03679368644952774,  -3.4928066730499268},
{1.7874181270599365,  0.8144195079803467,  -3.313753604888916,  0.9044064879417419,  -2.259305715560913},
{0.36165305972099304, -1.1717615127563477, -3.236488103866577,  0.8198288679122925,  7.1410298347473145},
{0.5099806785583496,  -0.45310789346694946,  0.4526544511318207,  -0.8899287581443787, -1.3834798336029053},
{0.6603919267654419,  0.4558185935020447,  -0.8554784059524536, -0.17991717159748077,  -0.17721225321292877},
{2.8645730018615723,  0.4576566517353058,  -4.317287921905518,  -0.36145997047424316,  1.2327181100845337},
{-4.437912464141846,  4.0488481521606445,  4.745065689086914, 1.0467711687088013,  1.6676031351089478},
{-0.8691045045852661, -0.1131659522652626, -0.40456104278564453,  1.2054157257080078,  1.4425396919250488}



}; 

// Pesos capa de salida
const float OutputWeights[OutputNodes][HiddenNodes+1]  = {
{6.187497615814209, 1.7991119623184204,  4.174306869506836, 2.8733344078063965,  6.656586647033691, 2.518364667892456, 1.6897099018096924,  -2.6747190952301025, -7.122068881988525,  2.3097269535064697,  1.2057197093963623

}
}; 

//Vector entrada A
const float A[1][DataVal]= {5, 5, 3, 2, 3, 3, 3, 3, 3, 3, 4, 1, 3, 5, 4, 5, 4, 1, 2, 1, 1, 2, 3, 5, 2, 1, 1, 1, 5, 2, 4, 1, 5, 2, 5, 4, 5, 1, 1, 5, 1, 4, 1, 4, 3, 2, 2, 3, 1, 1};
const float B[1][DataVal]= {4, 1, 4, 2, 1, 1, 5, 1, 1, 3, 1, 2, 3, 4, 3, 5, 2, 4, 2, 2, 3, 5, 2, 5, 5, 5, 2, 3, 3, 1, 4, 3, 1, 1, 5, 5, 2, 4, 4, 2, 2, 2, 1, 1, 5, 3, 5, 4, 2, 1};
const float C[1][DataVal]= {6, 4, 3, 4, 4, 5, 3, 3, 4, 3, 5, 5, 3, 5, 4, 6, 4, 4, 6, 4, 5, 4, 3, 4, 4, 3, 4, 3, 3, 3, 3, 3, 4, 5, 3, 3, 3, 4, 3, 4, 3, 4, 5, 3, 6, 3, 3, 4, 3, 6};
const float D[1][DataVal]= {5, 2, 1, 1, 2, 1, 1, 1, 3, 1, 4, 4, 2, 4, 3, 5, 2, 2, 5, 1, 4, 1, 1, 2, 3, 1, 2, 1, 2, 1, 2, 2, 1, 4, 1, 2, 1, 1, 1, 3, 1, 3, 4, 2, 5, 2, 1, 3, 2, 5};


float deseada[1][DataVal]={ 0.31875122,   0.99375594,  1.4999949,   0.58125305,  0.76875436,  0.5437528,   1.2999974,   4.299977,  1.0312537,   1.8999897,   0.431252,  0.58125305,  4.299977,  0.31875122,  0.5437528,  0.28125095,  0.35625148,  0.46875226,  0.5437528,   0.6187533,   0.5062525,   0.20625044,  3.899964,  0.5062525,   1.1062483,   3.899964,  0.8062546,   3.899964,  1.4999949,   5.100014,  1.4999949,   4.6999955,   0.88125515,  0.8062546,   0.7000007,   0.9000011,   1.4999949,   0.2437507,   4.0999675,  0.99375594 , 4.6999955,   0.58125305,  0.8062546,   2.6999795,   0.46875226,  4.499986,  3.6999667,   0.9562557,   4.499986,  0.8062546};
 


int i, j, p, q, r;
float Accum;
float Hidden[HiddenNodes];
float Output[OutputNodes];
float Input[InputNodes];  
 

void setup(){
  //start serial connection
  Serial.begin(9600);
}

void loop(){
  
  float Entrada;
  float Salida;
  float Tiempo;
  float des;


if (Samples<50)
{
  Input[0]=A[0][Samples];
  Input[1]=B[0][Samples];
  Input[2]=C[0][Samples];
  Input[3]=D[0][Samples];
  des=deseada[0][Samples];
  Samples=Samples+1;
}

if (Samples==50)
{
  Samples=0;
}


/******************************************************************
* Cálculo de la salida de capa oculta
******************************************************************/

    for( i = 0 ; i < HiddenNodes ; i++ ) {    
      Accum = HiddenWeights[i][InputNodes] ;
      for( j = 0 ; j < InputNodes ; j++ ) {
        Accum += HiddenWeights[i][j]*Input[j];
      }
      // función de activación sigmoidal y = 1 / (1 + exp(-x))
        Hidden[i] = (1)/(1+exp(-Accum));
     //   Hidden[i] = (exp(Accum)-exp(-Accum))/(exp(Accum)+exp(-Accum));
    }

/******************************************************************
* Cálculo de la salida de capa de salida
******************************************************************/
    for( i = 0 ; i < OutputNodes ; i++ ) {    
      Accum = OutputWeights[i][HiddenNodes] ;
      for( j = 0 ; j < HiddenNodes ; j++ ) {
        Accum +=  OutputWeights[i][j]*Hidden[j];
      }
      // función de activación lineal
        Output[i] = Accum; 

    }

Salida=Output[0];


Serial.print("Salida Red: "); 
Serial.print( Salida);    
Serial.print("  Salida Des: "); 
Serial.println( des);  

delay(50);  

}



